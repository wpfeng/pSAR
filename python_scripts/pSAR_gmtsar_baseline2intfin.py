#!/usr/bin/env python
#
#
import pSAR
import os
import sys
import numpy as np
import pGMT5SAR
#
def baselinedat2dates(inbase):
    #
    baseinfo = []
    prms = []
    baseinfo = []
    dates = []
    with open(inbase,'r') as fid:
        for cline in fid:
            cline = cline.split('\n')[0]
            tmp = cline.split()
            if len(tmp) > 4:
               dates.append(tmp[0].split('_')[1])
               prms.append(tmp[0])
               baseinfo.append([float(tmp[3]),float(tmp[4])])
    #
    return dates,prms,baseinfo
#
def ifinseason(d1,d2,md=24):
    # 
    # maximum of different days, md
    #
    fd1 = pSAR.ts.yyyymmdd2fracyear(d1)
    fd2 = pSAR.ts.yyyymmdd2fracyear(d2)
    day1 = int(str(fd1)[4:])
    day2 = int(str(fd2)[4:])
    if abs(day1-day2)<=md:
        return True
    else:
        return False
#
if len(sys.argv)<2:
    helpstr = \
        '''
        %s <in_base_file> <out_intf_list> <tmp_baseline> <spatial_baseline> 
           -master [None in default] -minnum [3 in default] -season
        ++++++++++++++++++++++++++++++++++++++
        To generate a pair list for use in GMTSAR

        -seasonal flag, if given, data in a similar season will be applied for interferometry
        

        <in_base_file> a baseline file generated by using pSAR_gmtsar_dir2baseline.py
                       baseline_tabel.csh, is used from GMTSAR
        ---
        by Wanpeng Feng, @SYSU, 2020/04/25
        
        ---
        added a new parameter -seasonal
        by Wanpeng Feng, @SYSU, Guangzhou, 2021/09/07

        '''
    print(helpstr % sys.argv[0])
    sys.exit(-1)
#
#
############################################################
# logging
#
pSAR.util.log(sys.argv)
#
#
minnum = 3
inbase  = sys.argv[1]
outintf = sys.argv[2]
tmpbase = float(sys.argv[3])
spbase  = float(sys.argv[4])
master  = None
seasond = None
#
for i,key in enumerate(sys.argv):
    #
    if key == '-season':
        seasond = int(sys.argv[i+1])
    if key == '-minnum':
        minnum = int(sys.argv[i+1])
    if key == '-outf':
        outintf = sys.argv[i+1]
    if key == '-master':
        master = sys.argv[i+1]
    #
#
if True:
    #
    if os.path.exists(outintf):
        os.system('rm %s -f' % outintf)
    #
    dates,prms,baseinfo = baselinedat2dates(inbase)
    #
    baseinfo = np.array(baseinfo)
    dates    = np.array(dates)
    prms     = np.array(prms)
    udates, unqindx = np.unique(dates, return_index=True)
    #
    prms = prms[unqindx]
    baseinfo = baseinfo[unqindx,:]
    # prms     = np.sort(prms)
    index    = np.argsort(prms)
    baseinfo = baseinfo[index,:]
    udates   = udates[index]
    # prms = prms[index]
    m_prms = []
    #
    #
    nprm = prms.shape[0]
    #
    tmp_prms = []
    for i,prm in enumerate(udates):
        #
        flag_m   = []
        date1    = udates[i]
        counter  = 0
        seasonflag = False 
        #
        #
        for j in range(i+1,nprm):
            #
            date2 = int(udates[j])
            #
            if seasond is not None:
              seasonflag = ifinseason(date1,date2,md=seasond)
            #
            diffdates = pSAR.ts.diff2dates(str(date1),str(date2)) 
            basediff = baseinfo[j,1] - baseinfo[i,1]
            # print(date1,date2,diffdates,basediff)
            counter = counter + 1
            flag = True
            #
            if diffdates > tmpbase or abs(basediff) > spbase or abs(basediff)==0:
                flag = False
            # 
            # below settings to make sure we have enough connections...
            #
            if counter < minnum and not flag:
                flag = True
            #
            if flag or seasonflag:
                flag = True
                seasonflag = False
                flag_m.append(flag)
                tmp_prms.append('%s:%s' % (prms[i],prms[j]))
            #
            # if flag:
            #   prm_str = '%s:%s' % (prm,prms[j])
            #   fid_out.write('%s\n' % prm_str)
        #
        # tmp_prms = np.array(tmp_prms)
        # flag_m   = np.array(flag_m)
        # numpairs = len(np.where(flag_m == True)[0])
        #
    #
    #
    fid_out = open(outintf,'w')
    #
    for i in range(len(tmp_prms)):
        fid_out.write('%s\n' % tmp_prms[i])
    #
    fid_out.close()
        #

